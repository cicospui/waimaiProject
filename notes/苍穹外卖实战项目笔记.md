苍穹外卖项目实战笔记

# Day01

该项目用到了以下的技术：

![1](D:\projects\java-waimai\waimaiProject\notes\figs\01-技术选型.png)

该项目因此需要两个前端和一个后端：

![1](figs/01-项目开发的结构.png)

代码结构为：

![1](figs/01-代码结构.png)

其中，pojo子项目中的分类为：

![1](figs/01-pojo中的分类.png)

## Nginx

nginx可以作为一个反向代理，对前端发送的动态请求转发到后端服务器。具有以下优点：

> 提高访问速度；
>
> 实现负载均衡；
>

### 反向代理

![1](figs/01-反向代理.png)

### 负载均衡

负载均衡的实现是可能基于以下策略的：

![1](figs/01-负载均衡的策略.png)

## 完善登录功能

将密码的部分增加了一个md5加密的过程：

> ```
> password = DigestUtils.md5DigestAsHex(password.getBytes());
> ```

## 接口设计

![1](figs/01-接口设计的过程.png)

所以在yapi中加入了管理端和验证端的接口信息。

## Swagger-后端接口测试技术

![1](figs/01-Swagger.png)

### API常用注解

![1](figs/01-常用注解.png)

通过接口注解，在接口文档就自动生成了对应的注解内容。

# Day02

## 员工管理

### 对象属性拷贝

经常用于DTO类型的数据属性传给原类型的过程。

```java
// 实用Spring带的对象属性拷贝
BeanUtils.copyProperties(employeeDTO, employee);
```

使用该方法将对象的属性方便地全部拷贝过去，但要求属性名得是一致的。

### 利用JWT令牌获得当前登录员工ID

JWT的过程如下图所示：

![1](figs/02-JWT的过程.png)

为了获得当前登陆的员工ID，就需要利用JWT令牌，从token中将ID解析出来。

### ThreadLocal技术

解析很好解析，但如何将解析出来的ID传递给其他方法用呢？这就涉及到了**ThreadLocal**。而可以使用的原因是：**客户端的每次请求都是一个单独的线程**。

![1](figs/02-线程共享.png)

### PageHelper一个分页查询小插件

可以通过PageHelper来辅助将结果分页查询：

```java
PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
```

### JWT令牌的有效期

因为在员工登陆时设置了令牌，同时在server的applicationa文件中对令牌设置了有效期。

```yml
sky:
  jwt:

    admin-secret-key: itcast

    admin-ttl: 7200000

    admin-token-name: token
```

因此，如果长时间不操作，就得重新登录获取令牌。Swagger测试代码时在“**全局参数设置**”中替换为新的令牌。

### 处理日期格式

两种方式对日期处理，前者要一个个设置，后者可以一劳永逸。

![1](figs/02-日期处理.png)

#### 方式一

```java
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime createTime;

@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime updateTime;
```

#### 方式二

```java
/*
扩展SpringMVC框架的消息转换器
 */
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters){
    // 创建一个消息转换器对象
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
    // 为消息转换器设置一个对象转换器,将java对象序列化为json数据,用于序列化和反序列化
    converter.setObjectMapper(new JacksonObjectMapper());
    // 将消息转换器添加到容器中
    converters.add(0,converter);
}
```

### 创建对象的Builder

如果类上有注解**@Builder**，则可以使用构造器构造对象，如下代码：

```java
//使用builder器创建对象
Employee.builder().status(status).id(id).build();
```

# Day03

## 公共字段自动填充

**公共字段**有以下几种，每次操作一般都需要对这些字段赋值的，就会产生很多冗余代码，后期维护不易变更。

![1](figs/03-公共字段.png)

### 实现思路

![1](figs/03-公共字段自动填充的实现思路.png)

这样的话，只需要在想要操作的方法上加上这个注解就可以了。

## 新增菜品

一个新增菜品的功能包含三个接口，而查询菜品是已有的接口。

### 文件上传

这部分需要用到阿里云的OSS服务，首先要在配置文件中进行如下配置，在dev/普通环境中使用不同的配置文件：

![1](figs/03-阿里云OSS配置.png)

### 菜品口味接口

需要设计一个DishFlavorMapper类，在新增菜品时对菜品的口味进行操作。

## 菜品分页查询



## 删除菜品

只用设计一个批量删除的接口，单个删除就是批量删除的特殊形式。但是如果用for循环包围，一次次执行单个删除操作，会产生较多次数的与数据库交互，这对性能的影响比较严重，可以通过优化SQL语句，一次交互达成多个效果：

```java
//        // 删除菜品表中的菜品数据
//        for(Long id : ids){
//            dishMapper.deleteById(id);
//            // 删除菜品关联的口味数据
//            dishFlavorMapper.deleteByDishId(id);
//        }
        dishMapper.deleteByIds(ids);
        dishFlavorMapper.deleteByDishIds(ids);
```

## 修改菜品

修改时，前端界面需要**回显菜品**的信息，所以这部分需要两个接口：根据ID查询菜品、修改菜品。

### 根据ID查询菜品

主要是在实现类中按照如下方法进行。

```java
public DishVO getByIdWithFlavor(Long id) {
    //根据id查询菜品
    Dish dish = dishMapper.getById(id);

    //根据ID查询口味数据
    List<DishFlavor> flavors = dishFlavorMapper.getByDishId(id);

    //查询到的数据封装VO
    DishVO dishVO = new DishVO();
    BeanUtils.copyProperties(dish,dishVO);
    //再额外封装一下口味数据
    dishVO.setFlavors(flavors);

    return dishVO;
}
```

### 修改菜品

修改菜品的逻辑为：

```java
public void updateWithFlavor(DishDTO dishDTO) {
    Dish dish = new Dish();
    BeanUtils.copyProperties(dishDTO, dish);

    // 修改菜品表
    dishMapper.update(dish);
    // 修改关联的口味表，比较复杂，为了简单起见，可以先全部删除再新增。
    dishFlavorMapper.deleteByDishId(dishDTO.getId());
    //重新插入口味数据
    List<DishFlavor> flavors = dishDTO.getFlavors();
    if(flavors != null && flavors.size() > 0){  //口味是可能为空的
        //先为这些口味表插入dishId
        for (DishFlavor flavor : flavors) {
            flavor.setDishId(dishDTO.getId());
        }
        dishFlavorMapper.insertBatch(flavors);
    }
}
```

# Day04

## 实战项目

